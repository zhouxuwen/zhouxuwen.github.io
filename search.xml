<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang性能优化篇</title>
    <url>/2022/02/11/Golang%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>在编写代码时常使用且常忽视的性能问题进行总结。这篇文章将持续更新…</p>
</blockquote>
<a id="more"></a>

<h2 id="string-和-byte-相互转换"><a href="#string-和-byte-相互转换" class="headerlink" title="string 和 []byte 相互转换"></a>string 和 []byte 相互转换</h2><p>无论是从哪种类型转换到另一种都需要对其中的内容进行拷贝，string 和 []byte 相互转换 也不例外，内存拷贝的性能损耗会随着字符串数组和字节长度的增长而增长，所以在做这种类型转换时一定要注意性能上的问题。</p>
<p>接下来我们可以使用一些方法来避免这种大批量的拷贝工作，这个方法就是可以绕过类型检查的 unsafe.Pointer</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">   x := (*[<span class="number">2</span>]<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">   b := [<span class="number">3</span>]<span class="keyword">uintptr</span>&#123;x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">1</span>]&#125;</span><br><span class="line">   <span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2str</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>字符串连接有很多方法：</p>
<ol>
<li>直接通过运算符<code>+</code></li>
<li>fmt.Sprintf()</li>
<li>bytes.Buffer{}</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Buffer</span><span class="params">(str ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	buffer := bytes.Buffer&#123;&#125;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		n += <span class="built_in">len</span>(s)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buffer.Grow(n)</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		buffer.WriteString(s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buffer.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>strings.Builder{}</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Builder</span><span class="params">(str ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	builder := strings.Builder&#123;&#125;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		n += <span class="built_in">len</span>(s)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	builder.Grow(n)</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		builder.WriteString(s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>copy方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(str ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(str) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> str[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		n += <span class="built_in">len</span>(Str2Bytes(s))</span><br><span class="line">	&#125;</span><br><span class="line">	bytes := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">	c := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		c += <span class="built_in">copy</span>(bytes[c:], Str2Bytes(s))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Bytes2Str(bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>既然方法有这么多种，性能问题就会有差异，通过benchmark测试查看一下:</p>
<p><img src="/images/benchmark-2022021101.png" alt="benchmark-2022021101"></p>
<p>可以看出copy和strings.Builder性能上是最好的，fmt.Sprintf是最差的，为什么呢？要知道golang 里面的字符串都是不可变的，每次运算都会产生一个新的字符串，所以会产生很多临时的无用的字符串，不仅没有用，还会给 gc 带来额外的负担，所以性能变差。而copy和strings.Builder根据长度预先分配内存，没有产生很多临时的无用的字符串。本质上就是以空间换时间。</p>
<h2 id="json序列化"><a href="#json序列化" class="headerlink" title="json序列化"></a>json序列化</h2><p>json系列我们最常用的就是标准库里的encoding/json，但为提高性能可以使用一些第三方库替换。如json-iterator、easyjson等。</p>
<p>性能提升多少呢？我们通过banchmark测试看一下:</p>
<p><img src="/images/benchmark-2022021102.png" alt="benchmark-2022021101"></p>
<p>可以看到json-iterator和easyjson相比easyjson提升整整一倍。但第三方库有一定的维护成本，但数据量大的时候，使用第三方库也是值得的。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>json</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>Go每周一库之wire</title>
    <url>/2022/06/16/Go%E6%AF%8F%E5%91%A8%E4%B8%80%E5%BA%93%E4%B9%8Bwire/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/google/wire">wire</a> 是go语言的自动初始化代码生成工具，可以根据对象的依赖关系生成初始化对象并自动连接组件，通过自动生成代码的方式在编译期完成依赖注入；其实它的代码生成功能和手写无异，在简化工作上并没有太大的感受，但是我更多的是想推荐它的编程思想，将模块进行解耦，更容易维护；</p>
</blockquote>
<a id="more"></a>



<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go install github.com&#x2F;google&#x2F;wire&#x2F;cmd&#x2F;wire@latest</span><br></pre></td></tr></table></figure>



<h2 id="两个核心概念-provider-和-injector"><a href="#两个核心概念-provider-和-injector" class="headerlink" title="两个核心概念 provider 和 injector"></a>两个核心概念 provider 和 injector</h2><h3 id="provider提供者"><a href="#provider提供者" class="headerlink" title="provider提供者"></a>provider提供者</h3><p>可以理解为对象的提供者；其实就是一个函数，它可能依赖一个对象，并且返回一个对象；以下三个函数都可以称为提供者；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProvideFoo</span><span class="params">()</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Foo&#123;X: <span class="number">24</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProvideBar</span><span class="params">(foo Foo)</span> <span class="title">Bar</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Bar&#123;X: foo.X&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProvideBaz</span><span class="params">(ctx context.Context, bar Bar)</span> <span class="title">Baz</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Baz&#123;X: bar.X&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供者可以使用<code>wire.NewSet()</code>合并成提供者集；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Set &#x3D; wire.NewSet(ProvideFoo, ProvideBar, ProvideBaz)</span><br></pre></td></tr></table></figure>



<h3 id="injector注入器"><a href="#injector注入器" class="headerlink" title="injector注入器"></a>injector注入器</h3><p>可以使用提供者集的依赖关系通过wire生成初始化代码；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">(ctx context.Context)</span> <span class="title">Baz</span></span> &#123;</span><br><span class="line">	wire.Build(Set)</span><br><span class="line">	<span class="keyword">return</span> Baz&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们已经安装了wire，通过<code>wire</code>命令执行生成代码，生成<code>wire_gen.go</code>文件如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by Wire. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate go run github.com/google/wire/cmd/wire</span></span><br><span class="line"><span class="comment">//+build !wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Injectors from wire.go:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">(ctx context.Context)</span> <span class="title">Baz</span></span> &#123;</span><br><span class="line">	foo := ProvideFoo()</span><br><span class="line">	bar := ProvideBar(foo)</span><br><span class="line">	baz := ProvideBaz(ctx, bar)</span><br><span class="line">	<span class="keyword">return</span> baz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有两个initialize函数，但是上面那个其实是代码生成用的，所以我们可以在文件顶部添加如下来忽略：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build wireinject</span></span><br></pre></td></tr></table></figure>





<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="绑定接口"><a href="#绑定接口" class="headerlink" title="绑定接口"></a>绑定接口</h3><p>当提供者注入的对象是接口且另一个提供者返回的实现接口的对象，这时就需要通过<code>wind.Bind()</code>绑定接口来确认依赖关系；示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fooer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Foo() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyFoo <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *MyFoo)</span> <span class="title">Foo</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(*f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProvideMyFoo</span><span class="params">()</span> *<span class="title">MyFoo</span></span> &#123;</span><br><span class="line">	f := MyFoo(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProvideMyBaz</span><span class="params">(f Fooer)</span> <span class="title">Baz</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Baz&#123;f.Foo()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>ProvideMyBaz()</code>依赖<code>Fooer</code>，而<code>ProvideMyFoo</code>返回的是<code>MyFoo</code>,<code>MyFoo</code>实现了<code>Fooer</code>接口；可以通过下面的方式确认依赖关系；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> BindSet = wire.NewSet(ProvideMyFoo, ProvideMyBaz, wire.Bind(<span class="built_in">new</span>(Fooer), <span class="built_in">new</span>(*MyFoo)))</span><br></pre></td></tr></table></figure>



<h3 id="结构结构者"><a href="#结构结构者" class="headerlink" title="结构结构者"></a>结构结构者</h3><p>当需要将提供者注入到结构体中的某个字段中时，可以通过<code>wire.Struct()</code>来进行依赖注入，先看下面的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> BType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SType <span class="keyword">struct</span> &#123;</span><br><span class="line">	A *AType</span><br><span class="line">	B BType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProvideA</span><span class="params">()</span> *<span class="title">AType</span></span> &#123;</span><br><span class="line">	i := AType(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProvideB</span><span class="params">()</span> <span class="title">BType</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想将<code>AType</code>和<code>BType</code>注入到<code>SType</code>,更传统的方法可能是直接再写一个提供者，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProvideS</span><span class="params">(a *AType, b BType)</span> <span class="title">SType</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> SType&#123;</span><br><span class="line">		A: a,</span><br><span class="line">		B: b,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> StructSet = wire.NewSet(ProvideB, ProvideA, ProvideS)</span><br></pre></td></tr></table></figure>

<p>但是我们也可以使用<code>wire.Struct()</code>实现结构提供者更方便的依赖注入,需要指明要注入的字段名称；也可以用<code>*</code>表示要注入所有字段；在注入使用字段时，如果有不需要注入的字段可以通过<code>wire:&quot;-&quot;</code>标签来进行忽略；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> StructSet = wire.NewSet(ProvideB, ProvideA, wire.Struct(<span class="built_in">new</span>(SType), <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>))</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">var</span> StructSet = wire.NewSet(ProvideB, ProvideA, wire.Struct(<span class="built_in">new</span>(SType), <span class="string">&quot;*&quot;</span>))</span><br></pre></td></tr></table></figure>



<h3 id="绑定值"><a href="#绑定值" class="headerlink" title="绑定值"></a>绑定值</h3><p>可以通过<code>wire.Value()</code>将默认值注入到结构体当中，接口类型使用<code>wire.InterfaceValue()</code>;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wire.Build(wire.Value(Value&#123;</span><br><span class="line">		A: <span class="number">1</span>,</span><br><span class="line">		B: <span class="number">2</span>,</span><br><span class="line">	&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="keyword">int</span></span><br><span class="line">	B <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">(ctx context.Context)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	value := _wireValueValue</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	_wireValueValue = Value&#123;</span><br><span class="line">		A: <span class="number">1</span>,</span><br><span class="line">		B: <span class="number">2</span>,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="使用结构字段作为提供者"><a href="#使用结构字段作为提供者" class="headerlink" title="使用结构字段作为提供者"></a>使用结构字段作为提供者</h3><p>可以通过<code>wire.FieldsOf</code>来使用结构体字段来作为提供者；通常如果不使用这个方法我们就需要写一个函数来获取结构体中的某个字段；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="keyword">int</span></span><br><span class="line">	B <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProvideValue</span><span class="params">()</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Value&#123;</span><br><span class="line">		A: <span class="number">1</span>,</span><br><span class="line">		B: <span class="number">2</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetA</span><span class="params">(v Value)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ValueSet = wire.NewSet(ProvideValue, GetA)</span><br></pre></td></tr></table></figure>

<p>其中<code>GetA</code>其实就是获取结构体<code>Value</code>中的<code>A</code>字段，如下通过使用<code>wire.FieldsOf</code>可以大大简化代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ValueSet &#x3D; wire.NewSet(ProvideValue, wire.FieldsOf(new(Value), &quot;A&quot;))</span><br></pre></td></tr></table></figure>



<h3 id="回调功能"><a href="#回调功能" class="headerlink" title="回调功能"></a>回调功能</h3><p>如果提供者需要一个回调方法（如关闭文件），那么它可以返回一个闭包来进行回调。注入器将使用它向调用者返回一个聚合的清理函数，或者如果稍后在注入器的实现中调用的提供者返回错误或使用完毕，则进行回调清理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideFile</span><span class="params">(log Logger, path Path)</span> <span class="params">(*os.File, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">	f, err := os.Open(<span class="keyword">string</span>(path))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	cleanup := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Log(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		log.Log(<span class="string">&quot;close success&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f, cleanup, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整提供者如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123;</span><br><span class="line">	Log(s <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Log <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Log)</span> <span class="title">Log</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;log:&quot;</span> + s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideLog</span><span class="params">()</span> *<span class="title">Log</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Log&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Path <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">providePath</span><span class="params">()</span> <span class="title">Path</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;a.txt&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FileSet = wire.NewSet(provideFile, provideLog, providePath, wire.Bind(<span class="built_in">new</span>(Logger), <span class="built_in">new</span>(*Log)))</span><br></pre></td></tr></table></figure>

<p>注入器如下, 可以通过<code>panic</code>省去return默认值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">(ctx context.Context)</span> <span class="params">(*os.File, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(wire.Build(FileSet))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wire</code>生成代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">(ctx context.Context)</span> <span class="params">(*os.File, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">   log := provideLog()</span><br><span class="line">   path := providePath()</span><br><span class="line">   file, cleanup, err := provideFile(log, path)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> file, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      cleanup()</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后测试运行一下, 运行结果打印文件<code>a.txt</code>的内容和<code>close success</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, cleanup, err := initialize(context.TODO())</span><br><span class="line">	<span class="keyword">defer</span> cleanup()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		i, err := file.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		data = <span class="built_in">append</span>(data, buf[:i]...)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>看完还不明白，建议查看github上的<a href="https://github.com/google/wire#documentation">官方文档</a>，上面详细介绍wire的用法和实践；</p>
]]></content>
  </entry>
  <entry>
    <title>Golang系列（一）-context使用</title>
    <url>/2021/07/12/Golang%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-context/</url>
    <content><![CDATA[<blockquote>
<p>go的context包详解，context中文翻译过来叫“上下文”，本篇文章讲一下它具体的作用是什么。你在什么情况下可以用到它。</p>
</blockquote>
<a id="more"></a>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>http server 常为每个请求创建一个 goroutine 以并发地处理请求，同时这个 goroutine 又会创建更多的 gotoutine 来访问数据库和缓存或RPC服务，当请求结束或被终止，能释放所有 gotoutine的资源。因此就需要一种机制，在goroutine之间传递信号消息。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>context 中文翻译过来叫”上下文“，常被用来 goroutine 之间传递信息和信号的。信息和信号包括截至时间（deadline)，取消信号(cancellation signals) 以及跨边界需要往下传递的键值对信息。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>context的设计是可通过已有Context进行树型派生，已管理一组过程的生命周期。单Context是不可变的，但可以通过WithValue、WithCancel、WithTimeout方法进行派生并附加一些属性（键值、可取消、时限），以构建一组树型组织的context。</li>
<li>当根 Context 结束时，所有由其派生出的 Context 也会被一并取消。也就是说，父 Context 的生命周期涵盖所有子 Context 的生命周期。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建根Context"><a href="#创建根Context" class="headerlink" title="创建根Context"></a>创建根Context</h3><p><code>context.Background() </code>创建一个空的Context（not nil), 常用作初始化创建根Context。</p>
<h3 id="派生携带键值信息Context"><a href="#派生携带键值信息Context" class="headerlink" title="派生携带键值信息Context"></a>派生携带键值信息Context</h3><p><code>context.WithValue(parentContext, key, value)</code> 在父节点Context的基础上创建一个新的携带键值信息的的子节点Context。</p>
<h3 id="派生可取消Context"><a href="#派生可取消Context" class="headerlink" title="派生可取消Context"></a>派生可取消Context</h3><p><code>context.WithCancel(parentContext) </code>在父节点Context的基础上创建一个新的可取消的子节点Context，返回新创建的子节点Context和取消方法cancelFunc。</p>
<h3 id="派生有时间限制Context"><a href="#派生有时间限制Context" class="headerlink" title="派生有时间限制Context"></a>派生有时间限制Context</h3><p><code>context.WithTimeout(parentContext，timeout)</code>在父节点Context的基础上创建新的有时间限制的子节点Context，返回新创建子节点Context和取消方法cancelFunc。超过时间限制后，该Conext会发送信号到Done通道，所有子节点检测到信号立即退出。</p>
<h3 id="派生有截至时间Context"><a href="#派生有截至时间Context" class="headerlink" title="派生有截至时间Context"></a>派生有截至时间Context</h3><p><code>context.WithDeadline(parentContext, time)</code>在父节点Context的基础上创建新的有截至时间的子节点Context,返回新创建子节点Context和取消方法cancelFunc。<code>context.Timeout(parentContext，timeout)</code>等价于<code>context.Deadline(parentContext,time.Now().Add(timeout))</code>。</p>
<p>​    </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>Background 创建的根节点没有时限，也不能取消。</li>
<li>WithCancel、WithTimeout、WithDeadline方法是从父context派生出新的context，新的context受限与父context的生命周期。新context应注意在对应过程结束后及时cancel，以防止goroutine泄露。</li>
<li>不能使用nil Context，尽管语法上允许。不知道使用什么值合适时，可以使用 <code>context.TODO()</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>context</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC序列（三）-gRPC安全认证</title>
    <url>/2021/07/15/RPC%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89-gRPC%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<blockquote>
<p>未认证的RPC服务可能导致服务被攻击、注入恶意数据、数据泄露等安全问题。gRPC框架自带的两种安全认证方式，这里简单介绍这两种认证方式，并用Golang进行简单实现。</p>
</blockquote>
<a id="more"></a>

<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>gRPC内置两种认证方式：</p>
<ul>
<li>SSL/TLS认证方式</li>
<li>自定义认证方式</li>
</ul>
<h3 id="SSL-TLS认证"><a href="#SSL-TLS认证" class="headerlink" title="SSL/TLS认证"></a>SSL/TLS认证</h3><p>什么是SSL/TLS呢？SSL是安全套接字层(secure sockets layer),TLS是传输层安全 (transport layer security)，就是在应用层和TCP层之间新加一层加密，这样可以保证信息传输的安全性。</p>
<h4 id="制作TLS证书"><a href="#制作TLS证书" class="headerlink" title="制作TLS证书"></a>制作TLS证书</h4><p>通过OpenSSL工具生成私钥，加密方式RSA，密码大小2048位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure>

<p>使用私钥生成自签名的证书文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650</span><br></pre></td></tr></table></figure>

<p>填入证书自定义信息，注意<code>server name </code>填写的内容，后面会用到。</p>
<h4 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h4><h5 id="First-server添加TLS认证"><a href="#First-server添加TLS认证" class="headerlink" title="First: server添加TLS认证"></a>First: server添加TLS认证</h5><p>通过密钥和刚刚制作的证书生成服务端传输证书。部分代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TLS认证</span></span><br><span class="line">creds, err := credentials.NewServerTLSFromFile(<span class="string">&quot;./keys/server.pem&quot;</span>, <span class="string">&quot;./keys/server.key&quot;</span> <span class="comment">/*制作证书存放路径*/</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;failed to generate credentials err:%v\n&quot;</span>, err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">server := grpc.NewServer(grpc.Creds(creds))</span><br></pre></td></tr></table></figure>

<h5 id="Second-client添加TLS认证"><a href="#Second-client添加TLS认证" class="headerlink" title="Second: client添加TLS认证"></a>Second: client添加TLS认证</h5><p>通过制作的证书生成客户端传输证书。部分代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TLS认证</span></span><br><span class="line">creds, err := credentials.NewClientTLSFromFile(<span class="string">&quot;./keys/server.pem&quot;</span>, <span class="string">&quot;server name&quot;</span> <span class="comment">/*制作证书时的server name*/</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;failed to generate credentials err:%v\n&quot;</span>, err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;localhost:9000&quot;</span>, grpc.WithTransportCredentials(creds))</span><br></pre></td></tr></table></figure>

<p>到这里gRPC的TLS单向认证的简单实现就完成了。</p>
<h3 id="自定义Token认证"><a href="#自定义Token认证" class="headerlink" title="自定义Token认证"></a>自定义Token认证</h3><p>通过自定义的身份认证方式进行认证客户端是否有权限。简单理解就是处理请求前对请求的内容进行身份认证。</p>
<h4 id="示例项目-1"><a href="#示例项目-1" class="headerlink" title="示例项目"></a>示例项目</h4><h5 id="First-server添加鉴权拦截器"><a href="#First-server添加鉴权拦截器" class="headerlink" title="First: server添加鉴权拦截器"></a>First: server添加鉴权拦截器</h5><p>新增鉴权拦截器，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Interceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	err := Auth(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 继续处理请求</span></span><br><span class="line">	<span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Auth</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;无Token认证信息&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// authentication</span></span><br><span class="line">	val := md.Get(<span class="string">&quot;app_id&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(val) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;app_id is empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	appID := val[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	val = md.Get(<span class="string">&quot;secret_key&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(val) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;secret_key is empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	appKey := val[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单模拟鉴权方式</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := tokenMap[appID]; !ok || appKey != tokenMap[appID] &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;unauthorized&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将鉴权拦截器加入服务选项，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// token auth</span></span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.UnaryInterceptor(interceptor.Interceptor))</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc server</span></span><br><span class="line">server := grpc.NewServer(opts...)</span><br></pre></td></tr></table></figure>



<h5 id="second-client添加身份认证请求参数"><a href="#second-client添加身份认证请求参数" class="headerlink" title="second: client添加身份认证请求参数"></a>second: client添加身份认证请求参数</h5><h6 id="方式一：实现PerRPCCredentials接口"><a href="#方式一：实现PerRPCCredentials接口" class="headerlink" title="方式一：实现PerRPCCredentials接口"></a>方式一：实现PerRPCCredentials接口</h6><p>该接口有两个方法</p>
<ol>
<li><code>GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) </code> 返回请求的身份认证数据。</li>
<li><code>RequireTransportSecurity() bool </code>返回是否开启TLS认证</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> authCredential <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*authCredential)</span> <span class="title">GetRequestMetadata</span><span class="params">(ctx context.Context, uri ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;app_id&quot;</span>:<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;secret_key&quot;</span>:<span class="string">&quot;key&quot;</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*authCredential)</span> 	<span class="title">RequireTransportSecurity</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将该自定义认证加入到客户端选项中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义认证方式</span></span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.WithPerRPCCredentials(<span class="built_in">new</span>(authCredential)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="方式二：context添加元数据"><a href="#方式二：context添加元数据" class="headerlink" title="方式二：context添加元数据"></a>方式二：context添加元数据</h6><p>请求方法的context添加身份认证元数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 认证参数</span></span><br><span class="line">md := metadata.Pairs(<span class="string">&quot;app_id&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;secret_key&quot;</span>, <span class="string">&quot;secret_key&quot;</span>)</span><br><span class="line">ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo </span></span><br><span class="line"><span class="comment">// resp := client.Function(ctx, reqMsg...)</span></span><br></pre></td></tr></table></figure>

<p>到这自定义身份认证的简单实现就完成了。</p>
<h3 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zhouxuwen&#x2F;grpcdemo-go.git</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
        <tag>RPC</tag>
        <tag>SSL/TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>Go每周一库之Logrus</title>
    <url>/2022/06/08/Go%E6%AF%8F%E5%91%A8%E4%B8%80%E5%BA%93%E4%B9%8BLogrus/</url>
    <content><![CDATA[<blockquote>
<p>golang开发者常用的日志三方库<a href="https://github.com/sirupsen/logrus">Logrus</a>；具备兼容性、扩展性等多种优点；本篇博客结合源码来分析它的设计思路和更高级的使用方法；</p>
</blockquote>
<a id="more"></a>



<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>官方给到的介绍 <a href="https://github.com/sirupsen/logrus">Logrus</a> 是 Go (golang) 的结构化记录器，与标准库记录器完全 API 兼容。</p>
<p>包含三大组成部分：日志等级、打印信息、输出样式；</p>
<h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><p>日志等级从低到高（<strong>Panic</strong>、、<strong>Error</strong>、<strong>Warn</strong>、<strong>Info</strong>、<strong>Debug</strong>、<strong>Trace</strong>）</p>
<p>在<code>exported.go</code>中实现了一个标准logger对象<code>std</code>；其默认的日志记录等级是<code>Info</code>，只有当打印等级低于日志记录等级才会进行输出（祥见<code>export.go</code>中<code>IsLevelEnabled</code>方法)；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// std is the name of the standard logger in stdlib `log`</span></span><br><span class="line">	std = New()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// It&#x27;s recommended to make this a global instance called `log`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Logger</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Logger&#123;</span><br><span class="line">		Out:          os.Stderr,</span><br><span class="line">		Formatter:    <span class="built_in">new</span>(TextFormatter),</span><br><span class="line">		Hooks:        <span class="built_in">make</span>(LevelHooks),</span><br><span class="line">		Level:        InfoLevel,</span><br><span class="line">		ExitFunc:     os.Exit,</span><br><span class="line">		ReportCaller: <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IsLevelEnabled checks if the log level of the logger is greater than the level param</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(logger *Logger)</span> <span class="title">IsLevelEnabled</span><span class="params">(level Level)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> logger.level() &gt;= level</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Entry和Logger两者的关系"><a href="#Entry和Logger两者的关系" class="headerlink" title="Entry和Logger两者的关系"></a>Entry和Logger两者的关系</h2><p><strong>Entry</strong>和<strong>Logger</strong>是整个<strong>Logrus</strong>库中最重要的两个数据结构；了解了这两者的关系你就能更清楚的知道<strong>Logrus</strong>的整个设计思路；</p>
<ul>
<li><strong>Logger</strong>是一个全局日志工具，所有记录日志的上层操作接口是由Logger提供，Entry属于单条日志记录的实体，Logger每打印一条日志，都对应创建一个Entry对象，并最后交由它处理；</li>
<li><strong>Entry</strong>是每条日志记录的实体，每记录一条日志，都会创建一个Entry对象，里面包含具体日志记录的数据字段和方法集；</li>
</ul>
<h2 id="exported中常用方法"><a href="#exported中常用方法" class="headerlink" title="exported中常用方法"></a>exported中常用方法</h2><p><code>exported.go</code>中实现了一个标准的logger对象，并提供基础方法；</p>
<h3 id="SetReportCaller"><a href="#SetReportCaller" class="headerlink" title="SetReportCaller"></a>SetReportCaller</h3><p><code>SetReportCaller(true)</code>方法其功能就是输出日志中添加文件名和方法信息；logger对象中有<code>ReportCaller</code>字段，用于是否记录调用者信息的标志，默认为false；Entry对象会根据这个标志创建Caller，Caller是<code>runtime.Frame</code>类型，可以检索第一个非 Logrus 调用函数的名称和包名；</p>
<h3 id="SetOutput"><a href="#SetOutput" class="headerlink" title="SetOutput"></a>SetOutput</h3><p><code>SetOutput()</code>方法可重定向日志输出到文件等;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetOutput sets the standard logger output.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetOutput</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	std.SetOutput(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SetFormatter"><a href="#SetFormatter" class="headerlink" title="SetFormatter"></a>SetFormatter</h3><p><code>SetFormatter()</code>可通过实现<code>Formatter</code>接口重新定义日志输出格式；Logrus已经实现了<code>JSONFormatter</code>和<code>TextFormatter</code>两种输出样式；也可以自己实现接口自定义输出样式；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Formatter <span class="keyword">interface</span> &#123;</span><br><span class="line">   Format(*Entry) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetFormatter sets the standard logger formatter.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFormatter</span><span class="params">(formatter Formatter)</span></span> &#123;</span><br><span class="line">	std.SetFormatter(formatter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AddHook"><a href="#AddHook" class="headerlink" title="AddHook"></a>AddHook</h3><p>Logrus可以通过添加钩子的方式来实现每条日志输出前都会执行钩子的特定方法；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AddHook adds a hook to the standard logger hooks.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddHook</span><span class="params">(hook Hook)</span></span> &#123;</span><br><span class="line">	std.AddHook(hook)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现Hook接口创建钩子，添加钩子对象会在entry的log方法中执行钩子方法fire()；从注释可以知道钩子方法的执行和日志等级应该，同时钩子方法并不会开辟goroutine进行执行;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A hook to be fired when logging on the logging levels returned from</span></span><br><span class="line"><span class="comment">//`Levels()` on your implementation of the interface. Note that this is //not fired in a goroutine or a channel with workers, you should handle //such functionality yourself if your call is non-blocking and you //don&#x27;t wish for the logging calls for levels returned from `Levels()` //to block.</span></span><br><span class="line"><span class="keyword">type</span> Hook <span class="keyword">interface</span> &#123;</span><br><span class="line">	Levels() []Level</span><br><span class="line">	Fire(*Entry) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三方Hook"><a href="#第三方Hook" class="headerlink" title="第三方Hook"></a>第三方Hook</h4><p>将日志发送到 缓冲或队列 等中间件中：</p>
<ul>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/weekface/mgorus">mgorus</a>：将日志发送到 mongodb；</p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/rogierlommers/logrus-redis-hook">logrus-redis-hook</a>：将日志发送到 redis；</p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/vladoatanasov/logrus_amqp">logrus-amqp</a>：将日志发送到 ActiveMQ；</p>
</li>
<li><p><a href="https://github.com/sirupsen/logrus/wiki/Hooks">wiki</a></p>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Logger是可以高度定制的，使用Hook钩子机制，Formatter定义日志格式，可以做到多级别输出、格式化输出、多样化输出。你学费了吗？</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>logrus</tag>
        <tag>日志</tag>
        <tag>三方库</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC系列（二）-gRPC入门</title>
    <url>/2021/07/08/RPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89-gRPC%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>简单介绍gRPC和ProtoBuf，以及gRPC和ProtoBuf的安装和简单使用，并用golang实现简单RPC服务。</p>
</blockquote>
<a id="more"></a>

<h2 id="gRPC简介"><a href="#gRPC简介" class="headerlink" title="gRPC简介"></a>gRPC简介</h2><p><a href="https://grpc.io/">gRPC</a> 是由Google开发的远程过程调用开源框架，支持多种开发语言，且支持跨语言通信。是基于HTTP2通信协议标准设计开发,默认采用Protocol Buffers数据序列化协议。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get google.golang.org&#x2F;grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">go install google.golang.org&#x2F;protobuf&#x2F;cmd&#x2F;protoc-gen-go</span><br><span class="line">go install google.golang.org&#x2F;grpc&#x2F;cmd&#x2F;protoc-gen-go-grpc</span><br></pre></td></tr></table></figure>



<h2 id="ProtoBuf简介"><a href="#ProtoBuf简介" class="headerlink" title="ProtoBuf简介"></a>ProtoBuf简介</h2><p>gRPC跨语言的支持都是通过<code>Protocol Buffers</code>这个东西，它是一个代码生成工具以及序列化工具。它可以把我们定义好的方法和数据结构转化成指定语言的代码。同时能将我们请求和响应的数据编码成gRPC能传输的形式，又能将数据序列化和反序列化成该语言能处理的形式。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info protobuf</span><br></pre></td></tr></table></figure>

<h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><p>这里不整理Protobuf文件的语法，<a href="http://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/gRPC/Protobuf%E8%AF%AD%E6%B3%95.html">Protobuf语法</a>看这里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoc -I&#x3D;$SRC_DIR --go_out&#x3D;$DST_DIR $SRC_DIR&#x2F;fileName.proto</span><br><span class="line"></span><br><span class="line">protoc -I&#x3D;$SRC_DIR --go-grpc_out&#x3D;$DST_DIR $SRC_DIR&#x2F;fileName.proto</span><br></pre></td></tr></table></figure>

<p>$SRC_DIR : 待编译的proto文件所在目录</p>
<p>$DST_DIR：生成后的代码所存放的目录</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="First-proto文件编写和生成源码"><a href="#First-proto文件编写和生成源码" class="headerlink" title="First: proto文件编写和生成源码"></a>First: proto文件编写和生成源码</h3><p>proto文件书写，先定义该通信用到的数据类型和结构，请求和响应的数据模型。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Massage</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> request = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义该通信的方法，只需要定义方法名、请求参数、响应参数即可。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Hello(Massage) <span class="keyword">returns</span> (Massage)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过protoc命名生成指定语言的代码，这里是生成go语言的代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. massage.proto</span><br><span class="line">protoc --go-grpc_out=. massage.proto</span><br></pre></td></tr></table></figure>



<h3 id="Second-Server代码编写"><a href="#Second-Server代码编写" class="headerlink" title="Second: Server代码编写"></a>Second: Server代码编写</h3><p>HelloService方法的具体实现，这里简单实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *helloService)</span> <span class="title">Hello</span><span class="params">(c context.Context, requestMessage *protobuf.Massage)</span> <span class="params">(responseMessage *protobuf.Massage, err error)</span></span> &#123;</span><br><span class="line">	msg := <span class="string">&quot;hello &quot;</span> + requestMessage.Request</span><br><span class="line">	responseMessage = &amp;protobuf.Massage&#123;Request: msg&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建rpc服务，注册通信方法的具体实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">server := grpc.NewServer()</span><br><span class="line">protobuf.RegisterHelloServiceServer(server, &amp;service.HelloService)</span><br></pre></td></tr></table></figure>

<p>监听端口，至此简单的rpc服务就写完了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:9000&quot;</span>)</span><br><span class="line">err = server.Serve(listen)</span><br></pre></td></tr></table></figure>



<h3 id="Third：Client代码编写"><a href="#Third：Client代码编写" class="headerlink" title="Third：Client代码编写"></a>Third：Client代码编写</h3><p>创建rpc客户端，建立连接。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := grpc.Dial(<span class="string">&quot;localhost:9000&quot;</span>, grpc.WithInsecure())</span><br><span class="line">c := protobuf.NewHelloServiceClient(conn)</span><br></pre></td></tr></table></figure>

<p>发送请求信息以及读取响应信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">requestMessage := &amp;protobuf.Massage&#123;Request: <span class="string">&quot;world &quot;</span>&#125;</span><br><span class="line">responseMessage, err := c.Hello(context.Background(), requestMessage)</span><br></pre></td></tr></table></figure>



<h3 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zhouxuwen&#x2F;grpcdemo-go.git</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>gRPC</tag>
        <tag>RPC</tag>
        <tag>ProtoBuf</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC系列（一）-RPC与RUST比较</title>
    <url>/2021/07/06/RPC%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-RPC%E4%B8%8ERUST%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章主要介绍RPC是什么，RPC的具体过程，RPC和RUST的比较以及如何选择。</p>
</blockquote>
<a id="more"></a>

<h2 id="RPC是什么"><a href="#RPC是什么" class="headerlink" title="RPC是什么"></a>RPC是什么</h2><p>RPC(Remote Procedure Call)是远程过程调用的简称。主要目的就是一个应用调用另一个应用的方法，调用方通过调用代理方法的形式调用被调用方的实现方法。调用协议常包括通信协议和序列化协议。底层的通信协议可以是HTTP、TCP等，根据不同的RPC框架而定。序列化协议常用ProtoBuf协议。</p>
<h2 id="RPC具体过程"><a href="#RPC具体过程" class="headerlink" title="RPC具体过程"></a>RPC具体过程</h2><p><img src="/images/rpc%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="rpc具体流程"></p>
<h2 id="RPC和RUST比较"><a href="#RPC和RUST比较" class="headerlink" title="RPC和RUST比较"></a>RPC和RUST比较</h2><p>RUST是基于HTTP协议的RESTFul API设计风格的通信方式，也常用于应用之间的信息通信。但设计理念和底层原理是完全不同的。</p>
<p>HTTP+Rustful的优点是可读性好，支持跨语言。在运用之间通信的使用超越RPC。但缺点也很明显，HTTP是第七层协议，报文包含大量头部信息，有用信息占比少，因此效率和速度较低。另外使用HTTP协议调用接口封装封装，常需要封装很多参数以及校验方法。RPC则更好与其互补，但牺牲可读性来通过效率和性能是可取的。具体怎么选，需根据业务来，灵活站位。</p>
<h2 id="RPC使用场景"><a href="#RPC使用场景" class="headerlink" title="RPC使用场景"></a>RPC使用场景</h2><p>Rustful常用于与第三方系统之间的信息通信，通过对外调用的接口。</p>
<p>RPC常用于自家系统之间的互相调用，更安全高效。</p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>RUST</tag>
        <tag>Rustful</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC系列（四）-HTTP网关</title>
    <url>/2021/07/17/RPC%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-HTTP%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<blockquote>
<p>gPRC网关是通过接收HTTP请求进行转换成gRPC的客户端请求发送给服务端的过程。这里介绍gRPC中HTTP网关的具体实现以及代码实现。</p>
</blockquote>
<a id="more"></a>

<h2 id="HTTP网关"><a href="#HTTP网关" class="headerlink" title="HTTP网关"></a>HTTP网关</h2><p>​        有时同一套业务代码我们既需要gRPC服务又需要HTTP服务，写两个服务又有点重复工作，而且维护两个版本的服务显然又不太合理，于是GRPC网关（grpc-gateway）就诞生了。它是通过protobuf的自定义option实现了一个网关，服务可以开启HTTP服务来接收HTTP请求，通过将请求数据转换成gRPC客户端请求发送个gRPC服务端，服务又将gRPC服务端的响应转化成HTTP响应返回给请求方。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装grpc-gateway, 这样protobuf就能生成gRPC网关相关代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com&#x2F;grpc-ecosystem&#x2F;grpc-gateway&#x2F;protoc-gen-grpc-gateway</span><br></pre></td></tr></table></figure>





<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h3><p>通过开启一个HTTP服务来接收http请求，通过将请求数据转换成gRPC客户端请求发送个gRPC服务端来实现整个请求过程。</p>
<h4 id="1-proto文件新增http-option"><a href="#1-proto文件新增http-option" class="headerlink" title="1.proto文件新增http option"></a>1.proto文件新增http option</h4><p>在前几节的massage.proto文件中的Hello方法新增http option, post请求，路由为<code>/hello</code>。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> protobuf;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./;protobuf&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/api/annotations.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Hello(Massage) <span class="keyword">returns</span> (Massage) </span>&#123;</span><br><span class="line">      <span class="comment">// http option</span></span><br><span class="line">      <span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">        post: <span class="string">&quot;/hello&quot;</span></span><br><span class="line">        body: <span class="string">&quot;*&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h4 id="2-生成gRPC网关相关代码"><a href="#2-生成gRPC网关相关代码" class="headerlink" title="2.生成gRPC网关相关代码"></a>2.生成gRPC网关相关代码</h4><p>通过protoc命令生成gRPC网关相关代码。这里需要引入google api的proto文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. -I=. -I$GOPATH/src/github.com/googleapis/googleapis massage.proto</span><br><span class="line"></span><br><span class="line">protoc --go-grpc_out=. -I=. -I$GOPATH/src/github.com/googleapis/googleapis massage.proto</span><br><span class="line"></span><br><span class="line">protoc --grpc-gateway_out=logtostderr=true:. -I=. -I$GOPATH/src/github.com/googleapis/googleapis massage.proto</span><br></pre></td></tr></table></figure>



<h4 id="3-新增HTTP服务代码"><a href="#3-新增HTTP服务代码" class="headerlink" title="3.新增HTTP服务代码"></a>3.新增HTTP服务代码</h4><p>新增http_server/main.go, 实现http服务，相关认证选项和拦截器选项参考前几章客户端请求选项，这里自演示部分代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endPoint := <span class="string">&quot;127.0.0.1:9000&quot;</span></span><br><span class="line">mux := runtime.NewServeMux()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加客户端请求选项</span></span><br><span class="line">opts := <span class="built_in">make</span>([]grpc.DialOption, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TLS认证（如果开启TLS认证）</span></span><br><span class="line">creds, err := credentials.NewClientTLSFromFile(<span class="string">&quot;./keys/server.pem&quot;</span>, <span class="string">&quot;www.zhouxuwen.com&quot;</span>)</span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.WithTransportCredentials(creds))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义认证方式（如果开启自定义认证）</span></span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.WithPerRPCCredentials(<span class="built_in">new</span>(authCredential)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP转grpc</span></span><br><span class="line">err = protobuf.RegisterHelloServiceHandlerFromEndpoint(ctx, mux, endPoint, opts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Register handler err:%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;HTTP Listen on 8080\n&quot;</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-启动HTTP服务和gRPC服务端"><a href="#4-启动HTTP服务和gRPC服务端" class="headerlink" title="4.启动HTTP服务和gRPC服务端"></a>4.启动HTTP服务和gRPC服务端</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X POST -d <span class="string">&#x27;&#123;&quot;massage&quot;:&quot;grpc gateway&quot;&#125;&#x27;</span> http://127.0.0.1:8080/hello</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#123;<span class="string">&quot;massage&quot;</span>:<span class="string">&quot;hello grpc gateway !&quot;</span>&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="升级gRPC服务端"><a href="#升级gRPC服务端" class="headerlink" title="升级gRPC服务端"></a>升级gRPC服务端</h3><p>上面方法通过新开启一个HTTP服务实现了通过http请求转换成gRPC客户端请求发送服务端。这样我们是同时开启HTTP和gRPC两个服务，虽然解决了了重复工作的问题，但我们还是得维护两个服务，也不太合适，我们可以将这两个服务整合在一起，共用同一端口号。同时提供http和gRPC两种调用方式。</p>
<h4 id="1-修改gRPC服务端代码"><a href="#1-修改gRPC服务端代码" class="headerlink" title="1.修改gRPC服务端代码"></a>1.修改gRPC服务端代码</h4><p>只需要修改gRPC服务端代码，将之前的gRPC服务端加上http网关相关，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	endPoint := <span class="string">&quot;localhost:9000&quot;</span></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, endPoint)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;tcp listen err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rpc server</span></span><br><span class="line">	opts := <span class="built_in">make</span>([]grpc.ServerOption, <span class="number">0</span>)</span><br><span class="line">	creds, err := credentials.NewServerTLSFromFile(<span class="string">&quot;./keys/server.pem&quot;</span>, <span class="string">&quot;./keys/server.key&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to generate credentials err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// TLS认证</span></span><br><span class="line">	opts = <span class="built_in">append</span>(opts, grpc.Creds(creds))</span><br><span class="line">	<span class="comment">// 自定义认证</span></span><br><span class="line">	opts = <span class="built_in">append</span>(opts, grpc.UnaryInterceptor(interceptor.Interceptor))</span><br><span class="line">	server := grpc.NewServer(opts...)</span><br><span class="line">	protobuf.RegisterHelloServiceServer(server, &amp;service.HelloService)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// http gateway server</span></span><br><span class="line">	gwOpts := <span class="built_in">make</span>([]grpc.DialOption, <span class="number">0</span>)</span><br><span class="line">	gwCreds, err := credentials.NewClientTLSFromFile(<span class="string">&quot;./keys/server.pem&quot;</span>, <span class="string">&quot;www.zhouxuwen.com&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to generate credentials err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// tls认证</span></span><br><span class="line">	gwOpts = <span class="built_in">append</span>(gwOpts, grpc.WithTransportCredentials(gwCreds))</span><br><span class="line">	<span class="comment">// 自定义认证方式</span></span><br><span class="line">	gwOpts = <span class="built_in">append</span>(gwOpts, grpc.WithPerRPCCredentials(&amp;interceptor.AuthCredential))</span><br><span class="line">	<span class="comment">// 请求拦截</span></span><br><span class="line">	gwOpts = <span class="built_in">append</span>(gwOpts, grpc.WithUnaryInterceptor(interceptor.ClientInterceptor))</span><br><span class="line"></span><br><span class="line">	gwmux := runtime.NewServeMux()</span><br><span class="line">	err = protobuf.RegisterHelloServiceHandlerFromEndpoint(context.Background(), gwmux, endPoint, gwOpts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;register http gateway server fail. err: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// http server</span></span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.Handle(<span class="string">&quot;/&quot;</span>, gwmux)</span><br><span class="line">	tlsConfig, err := getTLSConfig()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;get tls config err :%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// http and gRPC server</span></span><br><span class="line">	srv := &amp;http.Server&#123;</span><br><span class="line">		Addr:      endPoint,</span><br><span class="line">		Handler:   grpcHandlerFunc(server, mux),</span><br><span class="line">		TLSConfig: tlsConfig,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;gRPC and http listen at :%v\n&quot;</span>, endPoint)</span><br><span class="line">	err = srv.Serve(tls.NewListener(listen, tlsConfig))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, errors.New(fmt.Sprintf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTLSConfig</span><span class="params">()</span> <span class="params">(*tls.Config, error)</span></span> &#123;</span><br><span class="line">	cert, _ := ioutil.ReadFile(<span class="string">&quot;./keys/server.pem&quot;</span>)</span><br><span class="line">	key, _ := ioutil.ReadFile(<span class="string">&quot;./keys/server.key&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> demoKeyPair *tls.Certificate</span><br><span class="line">	pair, err := tls.X509KeyPair(cert, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;TLS KeyPair err: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	demoKeyPair = &amp;pair</span><br><span class="line">	<span class="keyword">return</span> &amp;tls.Config&#123;</span><br><span class="line">		Certificates: []tls.Certificate&#123;*demoKeyPair&#125;,</span><br><span class="line">		NextProtos:   []<span class="keyword">string</span>&#123;http2.NextProtoTLS&#125;, <span class="comment">// HTTP2 TLS支持</span></span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// grpcHandlerFunc returns an http.Handler that delegates to grpcServer on incoming gRPC</span></span><br><span class="line"><span class="comment">// connections or otherHandler otherwise. Copied from cockroachdb.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grpcHandlerFunc</span><span class="params">(grpcServer *grpc.Server, otherHandler http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> otherHandler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">			grpcServer.ServeHTTP(w, r)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoMajor == <span class="number">2</span> &amp;&amp; strings.Contains(r.Header.Get(<span class="string">&quot;Content-Type&quot;</span>), <span class="string">&quot;application/grpc&quot;</span>) &#123;</span><br><span class="line">			grpcServer.ServeHTTP(w, r)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			otherHandler.ServeHTTP(w, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-启动服务"><a href="#2-启动服务" class="headerlink" title="2.启动服务"></a>2.启动服务</h4><p>启动服务，通过gRPC客户端和http请求的方式进行验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X POST -k https://127.0.0.1:9000/hello -d <span class="string">&#x27;&#123;&quot;massage&quot;:&quot;grpc and http&quot;&#125;&#x27;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#123;<span class="string">&quot;massage&quot;</span>:<span class="string">&quot;hello grpc and http !&quot;</span>&#125;%</span></span><br></pre></td></tr></table></figure>



<h3 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zhouxuwen&#x2F;grpcdemo-go.git</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
        <tag>HTTP</tag>
        <tag>gateway</tag>
        <tag>grpc-gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构系列（一）-服务注册与发现（2）</title>
    <url>/2022/03/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>服务注册与发现之go语言设计与实现，为什么需要租约模式？watch机制解决了什么问题？</p>
</blockquote>
<a id="more"></a>



<h2 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1.定义接口"></a>1.定义接口</h2><p>首先确认整个流程需要做的事情；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建注册表对象,建立连接;</span><br><span class="line">2. 服务注册到注册表,定期续租;</span><br><span class="line">3. 服务从注册表中注销;</span><br><span class="line">4. 从注册表中获取服务列表;</span><br><span class="line">5. 监听key,当key变化时更新服务列表;</span><br></pre></td></tr></table></figure>

<p>从这些需要做的事情可以抽象出三个角色注册者（Registrar）、发现者（Discovery）、观察者（Watcher）以及方法。伪代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Registrar <span class="keyword">interface</span> &#123;</span><br><span class="line">  Register()</span><br><span class="line">  DeRegister()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Discovery <span class="keyword">interface</span> &#123; </span><br><span class="line">  Discover() []*Service</span><br><span class="line">  Watch(key <span class="keyword">string</span>) *Watcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Watcher <span class="keyword">interface</span> &#123;</span><br><span class="line">  Naxt() []*Service</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-实现接口"><a href="#2-实现接口" class="headerlink" title="2.实现接口"></a>2.实现接口</h2><h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-kratos/kratos/contrib/registry/consul/v2</span><br></pre></td></tr></table></figure>

<h3 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-kratos/kratos/contrib/registry/etcd/v2</span><br></pre></td></tr></table></figure>

<h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-kratos/kratos/contrib/registry/zookeeper/v2</span><br></pre></td></tr></table></figure>

<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-kratos/kratos/contrib/registry/nacos/v2</span><br></pre></td></tr></table></figure>

<h3 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-kratos/kratos/contrib/registry/kubernetes/v2</span><br></pre></td></tr></table></figure>

<h3 id="polaris"><a href="#polaris" class="headerlink" title="polaris"></a>polaris</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-kratos/kratos/contrib/registry/polaris/v2</span><br></pre></td></tr></table></figure>



<h2 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h2><h3 id="为什么需要租约模式？定期续租是为了什么？"><a href="#为什么需要租约模式？定期续租是为了什么？" class="headerlink" title="为什么需要租约模式？定期续租是为了什么？"></a>为什么需要租约模式？定期续租是为了什么？</h3><p>服务注册到注册表中，如果服务挂了，不从注册表中移除，它还会在注册表中，请求就可能进入异常服务中，这并不是我们想要的结果。于是便有了租约模式，服务需要定期发送续租请求，在指定时间（keepalive）内未发送请求，就认为服务处于异常状态，将被从注册表中移除。</p>
<h3 id="watch机制是解决什么问题？"><a href="#watch机制是解决什么问题？" class="headerlink" title="watch机制是解决什么问题？"></a>watch机制是解决什么问题？</h3><p>服务发现是从注册表中发现一组服务列表，服务列表并未更新，我们还是需要主动从注册表中获取服务列表，在我们看来服务列表未更新，这种操作是没必要的，为了避免这种反复轮询，便有了watch机制，从主动变成了被动，我们对key进行监听，如果key的value更新了，便进行通知，我们才去获取服务列表进行更新。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然服务注册与发现的基础使用是有了，但实际使用下来会有以下两个问题：</p>
<ol>
<li><p>服务发现获取到是服务列表，从中选择一个涉及负载均衡算法</p>
</li>
<li><p>服务发现获取的是服务连接信息，其中可能是http服务，可能是grpc服务，不能很好的使用；</p>
</li>
</ol>
<p>从这两个问题我们可以抽象几个角色选择器（Selecter）、均衡器（Banlancer）、解析器（Reslover）等。下一篇从这两个问题出发介绍这几个角色的实现。</p>
]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构系列（一）-服务注册与发现（3）</title>
    <url>/2022/03/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>从上一篇留下的两个问题出发，介绍从服务发现获取的服务注册列表中获取一个服务注册信息并将其实例成可使用的client对象的过程；</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从服务发现获取的服务注册列表中获取一个服务注册信息并将其实例成可使用的client对象需要经过以下步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、服务发现获取服务列表；对其进行监听，如果服务列表发生变化进行更新；</span><br><span class="line">1、服务列表连接和权重等信息构成节点列表；节点列表中节点再附加命中等信息构成加权节点列表供后续使用；</span><br><span class="line">2、从加权节点列表经过过滤后通过负载均衡算法选择其中一个节点；</span><br></pre></td></tr></table></figure>

<p>从以上步骤抽象出角色和接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reslover(解析器): 通过服务名(服务注册时的服务命名)解析成服务对象列表的过程；通过服务发现获取列表，服务监听更新列表；</span><br><span class="line">Selector(选择器): 将服务列表构建成具有权重和命中等信息的家权节点列表，通过均衡器从加权节点列表中选择一个节点的过程；</span><br><span class="line">Balancer(均衡器): 从节点列表中选择这个节点有不同的负载均衡算法；例如：wrr等</span><br></pre></td></tr></table></figure>

<p>接口定义伪代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Selector <span class="keyword">interface</span> &#123;</span><br><span class="line">	Apply([]Node)</span><br><span class="line">	Select() Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Balancer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Pick() Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResloverBuilder <span class="keyword">interface</span> &#123;</span><br><span class="line">	Build(Discovery, Selector, Target) Reslover</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reslover <span class="keyword">interface</span> &#123;</span><br><span class="line">	Update([]Service)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.com&#x2F;go-kratos&#x2F;kratos&#x2F;selector</span><br><span class="line">github.com&#x2F;go-kratos&#x2F;kratos&#x2F;transport</span><br></pre></td></tr></table></figure>

<p>其中grpc提供了解析器的reslover.Builder接口和reslover.Reslover接口以及均衡器的balancer.Picker接口和balancer.PickResult接口，实现这些接口并进行注册；</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这里只是简单介绍从服务发现获取的服务注册列表中获取一个服务注册信息并将其实例成可使用的client对象的过程，将角色和方法进行分解；具体实现还需要自己去看代码，最好再自己也实现一遍。</p>
]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构系列（一）-服务注册与发现</title>
    <url>/2022/02/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>为什么有服务注册与发现？解决了什么问题？如何使用？</p>
</blockquote>
<a id="more"></a>



<h2 id="为什么有服务注册与发现？解决了什么问题？"><a href="#为什么有服务注册与发现？解决了什么问题？" class="headerlink" title="为什么有服务注册与发现？解决了什么问题？"></a>为什么有服务注册与发现？解决了什么问题？</h2><p>​       服务根据功能进行了划分，各自负责自己的模块；但服务和服务之间还需要通信，服务部署很多台，我们要从中获取一台服务建立通信；如果没有服务注册和发现中间件我们要怎么做呢？大部分的做法可能是将所有服务的地址权重写在配置中，通过类负载均衡算法从中选择一个建立连接到达通信的目的，这么做是没问题的，但这么做方便吗？不方便。首先每次新增或移除一个服务都要更新配置文件，而且这类操作通常会比较频繁。其次如果是用容器部署的话，服务的地址都动态服务，如果还是通过人工进行配置，那对运维一点都不友好。服务注册与发现中间件是什么呢？它其实就是公共的服务，保存服务的注册信息，且必须具备高可用和一致性。服务注册时将信息记录，服务发现时获取注册列表。这不就解决了上面所说的问题。</p>
<h2 id="使用总结为三步："><a href="#使用总结为三步：" class="headerlink" title="使用总结为三步："></a>使用总结为三步：</h2><ol>
<li><p>服务提供者（Provider）与中间件服务（etcd、consul等）建立连接；</p>
</li>
<li><p>服务提供者向中间件服务注册，供其他服务调用；</p>
</li>
<li><p>服务消费者（consumer）从中间件服务发现服务（从服务列表中通过负载均衡算法选取）进行调用；</p>
</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​       打算写一个服务架构练练手，尽量功能齐全，集成所有市面上使用广泛的中间件。其实现在已经提出了服务网格（Service Mesh，已经有机会也会写写），相当于剥离了业务层和管理层，写代码只需要关注业务，无需关心基础设施层。但我为什么还要回过头去写老的服务机构呢？没为什么，就是学习，你写代码的时候也从来没去看过源码，但面试官就是爱问一个道理。</p>
]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>consul</tag>
      </tags>
  </entry>
</search>
